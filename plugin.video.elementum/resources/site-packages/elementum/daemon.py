import io
import os
import errno
import stat
import time
import shutil
import socket
import filecmp
import threading
import six

from kodi_six import xbmc, xbmcgui
from six.moves import urllib_request
from kodi_six.utils import py2_decode
from ctypes import c_char_p, c_int, cdll, Structure, c_longlong

from elementum.taller import follow
from elementum.logger import log
from elementum.osarch import PLATFORM, get_platform
from elementum.config import ELEMENTUMD_HOST
from elementum.addon import ADDON, ADDON_ID, ADDON_PATH, ADDON_VERSION
from elementum.util import (notify, dialog_ok, system_information, toUtf8,
                            download_github_folder, read_current_version, write_current_version,
                            download_current_version,
                            getLocalizedString, getWindowsShortPath, translatePath)

try:
    import subprocess
    hasSubprocess = True
    if not PLATFORM["fork"]:
        hasSubprocess = False
except:
    hasSubprocess = False

log_path = ""
last_exit_code = -1
binary_platform = {}
repo = "elgatito/elementum-binaries"

class GoString(Structure):
    _fields_ = [("p", c_char_p), ("n", c_longlong)]

def ensure_exec_perms(file_):
    st = os.stat(file_)
    os.chmod(file_, st.st_mode | stat.S_IEXEC)
    return file_

def android_get_current_appid():
    with open("/proc/%d/cmdline" % os.getpid()) as fp:
        return fp.read().rstrip("\0")

def get_elementumd_checksum(path):
    if not os.path.exists(path):
        return ""

    stats = os.stat(path)
    if stats.st_size < 40:
        return ""

    try:
        with open(path) as fp:
            fp.seek(-40, os.SEEK_END)  # we put a sha1 there
            return fp.read()
    except Exception:
        return ""


def get_elementum_binary():
    global binary_platform
    binary_platform = get_platform()

    binary = "elementum" + (binary_platform["os"] == "windows" and ".exe" or "")
    binary_dir = os.path.join(ADDON_PATH, "resources", "bin", "%(os)s_%(arch)s" % binary_platform)

    if binary_platform["os"] == "android":
        log.info("Detected binary folder: %s" % binary_dir)
        binary_dir_legacy = binary_dir.replace("/storage/emulated/0", "/storage/emulated/legacy")
        if os.path.exists(binary_dir_legacy):
            binary_dir = binary_dir_legacy
            log.info("Using changed binary folder for Android: %s" % binary_dir)

        app_id = android_get_current_appid()
        xbmc_data_path = os.path.join("/data", "data", app_id)
        if not os.path.exists(xbmc_data_path):
            log.info("%s path does not exist, so using %s as xbmc_data_path" % (xbmc_data_path, translatePath("special://xbmcbin/")))
            xbmc_data_path = translatePath("special://xbmcbin/")

        if not os.path.exists(xbmc_data_path):
            log.info("%s path does not exist, so using %s as xbmc_data_path" % (xbmc_data_path, translatePath("special://masterprofile/")))
            xbmc_data_path = translatePath("special://masterprofile/")

        dest_binary_dir = os.path.join(xbmc_data_path, "files", ADDON_ID, "bin", "%(os)s_%(arch)s" % binary_platform)
    else:
        try:
            dest_binary_dir = os.path.join(translatePath(ADDON.getAddonInfo("profile")).decode('utf-8'), "bin", "%(os)s_%(arch)s" % binary_platform)
        except Exception:
            dest_binary_dir = os.path.join(translatePath(ADDON.getAddonInfo("profile")), "bin", "%(os)s_%(arch)s" % binary_platform)

    binary_path = os.path.join(binary_dir, binary)
    dest_binary_path = os.path.join(dest_binary_dir, binary)
    installed_version = read_current_version(binary_dir)

    log.info("Binary detection. Version: %s, Source: %s, Destination: %s" % (installed_version, binary_path, dest_binary_path))

    if not os.path.exists(binary_path) or not installed_version or ADDON_VERSION > installed_version:
        try:
            os.makedirs(binary_dir)
        except OSError as e:
            if e.errno != errno.EEXIST:
                raise

        notify("LOCALIZE[30670];;" + "%(os)s_%(arch)s" % binary_platform)
        if not download_github_folder(repo, "%(os)s_%(arch)s" % binary_platform, binary_dir):
            log.error("Unable to download binary to destination path")
            system_information()
            return False, False
        version = download_current_version(repo)
        write_current_version(binary_dir, version)

    if not os.path.exists(binary_path):
        # notify((getLocalizedString(30103) + " %(os)s_%(arch)s" % PLATFORM), time=7000)
        dialog_ok("LOCALIZE[30347];;" + "%(os)s_%(arch)s" % binary_platform)
        system_information()
        try:
            log.info("Source directory (%s):\n%s" % (binary_dir, os.listdir(os.path.join(binary_dir, ".."))))
            log.info("Destination directory (%s):\n%s" % (dest_binary_dir, os.listdir(os.path.join(dest_binary_dir, ".."))))
        except Exception:
            pass
        return False, False

    if os.path.isdir(dest_binary_path):
        log.warning("Destination path is a directory, expected previous binary file, removing...")
        try:
            shutil.rmtree(dest_binary_path)
        except Exception as e:
            log.error("Unable to remove destination path for update: %s" % e)
            system_information()
            return False, False

    if not os.path.exists(dest_binary_path) or not os.path.exists(binary_path) or get_elementumd_checksum(dest_binary_path) != get_elementumd_checksum(binary_path) or not filecmp.cmp(dest_binary_path, binary_path, shallow=True):
        log.info("Updating elementum daemon...")
        try:
            os.makedirs(dest_binary_dir)
        except OSError:
            pass
        try:
            shutil.rmtree(dest_binary_dir)
        except Exception as e:
            log.error("Unable to remove destination path for update: %s" % e)
            system_information()
            pass
        try:
            shutil.copytree(binary_dir, dest_binary_dir)
        except Exception as e:
            log.error("Unable to copy to destination path for update: %s" % e)
            system_information()
            return False, False

    # Clean stale files in the directory, as this can cause headaches on
    # Android when they are unreachable
    dest_files = set(os.listdir(dest_binary_dir))
    orig_files = set(os.listdir(binary_dir))
    log.info("Deleting stale files %s" % (dest_files - orig_files))
    for file_ in (dest_files - orig_files):
        path = os.path.join(dest_binary_dir, file_)
        if os.path.isdir(path):
            shutil.rmtree(path)
        else:
            os.remove(path)

    log.info("Binary detection: [ Source: %s, Destination: %s ]" % (binary_path, dest_binary_path))
    return dest_binary_dir, ensure_exec_perms(dest_binary_path)

def clear_fd_inherit_flags():
    # Ensure the spawned Elementum binary doesn't inherit open files from Kodi
    # which can break things like addon updates. [WINDOWS ONLY]
    try:
        from ctypes import windll

        HANDLE_RANGE = six.moves.xrange(0, 65536)
        HANDLE_FLAG_INHERIT = 1
        FILE_TYPE_DISK = 1

        for hd in HANDLE_RANGE:
            if windll.kernel32.GetFileType(hd) == FILE_TYPE_DISK:
                if not windll.kernel32.SetHandleInformation(hd, HANDLE_FLAG_INHERIT, 0):
                    log.error("Error clearing inherit flag, disk file handle %x" % hd)
    except:
        pass

def jsonrpc_enabled(notify=False):
    try:
        s = socket.socket()
        s.connect(('127.0.0.1', 9090))
        s.close()
        log.info("Kodi's JSON-RPC service is available, starting up...")
        del s
        return True
    except Exception as e:
        log.error(repr(e))
        if notify:
            xbmc.executebuiltin("ActivateWindow(ServiceSettings)")
            dialog = xbmcgui.Dialog()
            dialog.ok("Elementum", getLocalizedString(30199))
    return False

def start_elementumd(**kwargs):
    global log_path

    jsonrpc_failures = 0
    while jsonrpc_enabled() is False:
        jsonrpc_failures += 1
        log.warning("Unable to connect to Kodi's JSON-RPC service, retrying...")
        if jsonrpc_failures > 1:
            time.sleep(5)
            if not jsonrpc_enabled(notify=True):
                log.error("Unable to reach Kodi's JSON-RPC service, aborting...")
                return False
            else:
                break
        time.sleep(3)

    elementum_dir, elementum_binary = get_elementum_binary()
    elementum_library = "elementum.so"

    log.info("Binary dir: %s, item: %s " % (elementum_dir, elementum_binary))
    if elementum_dir is False or elementum_binary is False:
        return False

    lockfile = os.path.join(ADDON_PATH, ".lockfile")
    if os.path.exists(lockfile):
        log.warning("Existing process found from lockfile, killing...")
        try:
            with open(lockfile) as lf:
                pid = int(lf.read().rstrip(" \t\r\n\0"))
            if pid != os.getpid():
                log.info("Killing process id %s" % pid)
                os.kill(pid, 9)
        except OSError as e:
            if e.errno != 3 and e.errno != 22:
                # Ignore:   OSError: [Errno 3] No such process
                log.error(repr(e))
        except Exception as e:
            log.error(repr(e))

        if binary_platform["os"] == "windows":
            try:
                library_lockfile = os.path.join(py2_decode(translatePath(ADDON.getAddonInfo("profile"))), "library.db.lock")
                if os.path.exists(library_lockfile):
                    log.warning("Removing library.db.lock file at %s ..." % library_lockfile)
                    os.remove(library_lockfile)
            except Exception as e:
                log.error(repr(e))

    SW_HIDE = 0
    STARTF_USESHOWWINDOW = 1

    args = [elementum_binary]
    shared_args = ""
    if ADDON.getSetting("local_port") != "":
        args.append("-remotePort=" + ADDON.getSetting("local_port"))
        shared_args += " -remotePort=" + ADDON.getSetting("local_port")
    if ADDON.getSetting("remote_host") != "":
        args.append("-localHost=" + ADDON.getSetting("remote_host"))
        shared_args += " -localHost=" + ADDON.getSetting("remote_host")
    if ADDON.getSetting("remote_port") != "":
        args.append("-localPort=" + ADDON.getSetting("remote_port"))
        shared_args += " -localPort=" + ADDON.getSetting("remote_port")
    kwargs["cwd"] = elementum_dir

    if binary_platform["os"] == "windows":
        args[0] = getWindowsShortPath(elementum_binary)
        kwargs["cwd"] = getWindowsShortPath(elementum_dir)
        si = subprocess.STARTUPINFO()
        si.dwFlags = STARTF_USESHOWWINDOW
        si.wShowWindow = SW_HIDE
        clear_fd_inherit_flags()
        kwargs["startupinfo"] = si
        elementum_library = "elementum.dll"
    else:
        env = os.environ.copy()
        env["LD_LIBRARY_PATH"] = "%s:%s" % (elementum_dir, env.get("LD_LIBRARY_PATH", ""))
        kwargs["env"] = env
        kwargs["close_fds"] = True

    wait_counter = 1
    log.debug("Checking for visible")
    while xbmc.getCondVisibility('Window.IsVisible(10140)') or xbmc.getCondVisibility('Window.IsActive(10140)'):
        if wait_counter == 1:
            log.info('Add-on settings currently opened, waiting before starting...')
        if wait_counter > 300:
            break
        time.sleep(1)
        wait_counter += 1

    log.info("elementumd: start args: %s, kw: %s" % (args, kwargs))
    delay = int(ADDON.getSetting("startup_delay"))
    if delay > 0:
        log.info("elementumd: sleeping %d seconds before startup" % (delay))
        time.sleep(delay)

    proc = None
    try:
        proc = subprocess.Popen(args, **kwargs)
    except:
        pass
    if not proc:
        try:
            log_dir = os.path.join(translatePath("special://temp/"), "elementum")
            log_path = os.path.join(log_dir, "elementum.log")

            # Create and truncate log file before starting the library
            try:
                if not os.path.exists(log_dir):
                    os.makedirs(log_dir)

                if not os.path.exists(log_path):
                    open(log_path, 'w').close()
                else:
                    with open(log_path, 'r+') as f:
                        f.truncate()
            except IOError as e:
                log.error("Could not truncate the log: %s" % (e))
                pass

            library_path = os.path.join(elementum_dir, elementum_library)
            log.info("elementumd: loading shared library from %s" % library_path)
            lib = cdll.LoadLibrary(library_path)

            library_thread = threading.Thread(target=start_library, args=[lib, log_path, shared_args])
            library_thread.start()

            return library_thread
        except Exception as e:
            log.error("Unable to start library: %s" % e)
            return None

    return proc


def start_library(lib, log_path, args):
    global last_exit_code

    log.info("Preparing start with args '%s' and log path: %s" % (args, log_path))

    lib.startWithLog.argtypes = [GoString, GoString]
    lib.startWithLog.restype = c_int

    last_exit_code = lib.startWithLog(GoString(c_char_p(log_path.encode('utf-8')), len(log_path)), GoString(c_char_p(args.encode('utf-8')), len(args)))
    log.info("Shared library execution stopped with code %d" % (last_exit_code))
    time.sleep(1)

def shutdown():
    try:
        urllib_request.urlopen(ELEMENTUMD_HOST + "/shutdown", timeout=1)
    except Exception:
        pass

def wait_for_abortRequested(proc, monitor):
    monitor.closing.wait()
    log.info("elementumd: exiting elementumd daemon")
    try:
        if not isinstance(proc, threading.Thread):
            proc.terminate()
    except OSError:
        pass  # Process already exited, nothing to terminate
    log.info("elementumd: elementumd daemon exited")

def elementumd_thread(monitor):
    restart_count = 0
    max_restart = 3
    last_code = 0

    try:
        monitor_abort = xbmc.Monitor()  # For Kodi >= 14
        while not monitor_abort.abortRequested():
            # If we ran out of attempts of last exit code was '-9': we do not try to start it again.
            # So if you kill the binary with '-9': it will not be restarted by this monitor.
            if restart_count > max_restart or last_code == -9:
                if monitor.reboot():
                    log.debug("elementumd: resetting attempts")
                    restart_count = 0
                    last_code = 0
                    monitor.reboot(False)
                else:
                    time.sleep(5)

                continue

            log.info("elementumd: starting elementumd")
            proc = start_elementumd(stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if proc is None:
                break
            else:
                threading.Thread(target=wait_for_abortRequested, args=[proc, monitor]).start()

                if isinstance(proc, threading.Thread):
                    while not os.path.exists(log_path):
                        time.sleep(1)

                    for line in follow(io.open(log_path, 'r', encoding='utf8'), delay=0.5, selector=proc.is_alive):
                        try:
                            log.info(toUtf8(line.rstrip()))
                        except UnicodeDecodeError:
                            log.info(line.rstrip())
                        if not proc.is_alive():
                            break
                    last_code = last_exit_code
                else:
                    if binary_platform["os"] == "windows":
                        while proc.poll() is None:
                            log.info(toUtf8(proc.stdout.readline().rstrip()))
                    else:
                        # Kodi hangs on some Android (sigh...) systems when doing a blocking
                        # read. We count on the fact that Elementum daemon flushes its log
                        # output on \n, creating a pretty clean output
                        import fcntl
                        import select
                        fd = proc.stdout.fileno()
                        fl = fcntl.fcntl(fd, fcntl.F_GETFL)
                        fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)
                        while proc.poll() is None:
                            try:
                                to_read, _, _ = select.select([proc.stdout], [], [])
                                for ro in to_read:
                                    line = ro.readline()
                                    if line == "":  # write end is closed
                                        break
                                    try:
                                        log.info(toUtf8(line.rstrip()))
                                    except TypeError:
                                        pass
                            except IOError:
                                time.sleep(1)  # nothing to read, sleep

                if not isinstance(proc, threading.Thread):
                    last_code = proc.returncode
                    if monitor_abort.abortRequested():
                        break
                    if proc.returncode == 0 or proc.returncode == -9 or proc.returncode == -1:
                        continue

                    if proc.returncode == 5:
                        restart_count = 0
                        notify(getLocalizedString(30332), time=3000)
                    else:
                        restart_count += 1
                        notify(getLocalizedString(30100), time=3000)
                else:
                    log.info("Joining library thread")
                    proc.join()
                    if monitor_abort.abortRequested():
                        break

                    if last_exit_code == 5:
                        restart_count = 0
                        notify(getLocalizedString(30332), time=3000)
                    else:
                        restart_count += 1
                        notify(getLocalizedString(30100), time=3000)

            xbmc.executebuiltin("Dialog.Close(all, true)")
            system_information()

            log.info("Sleeping before next restart attempt")
            time.sleep(5)

            if restart_count >= max_restart:
                log.debug("elementumd: no attempts left")
                notify(getLocalizedString(30110), time=3000)
                continue

    except Exception as e:
        import traceback
        map(log.error, traceback.format_exc().split("\n"))
        notify("%s: %s" % (getLocalizedString(30226), repr(e).encode('utf-8')))
        raise

    log.debug("elementumd: closing")
